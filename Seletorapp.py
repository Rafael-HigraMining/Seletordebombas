import streamlit as st
import pandas as pd
import numpy as np
import re
from urllib.parse import quote
import base64
from pathlib import Path

# ===================================================================
# FUN√á√ÉO AUXILIAR PARA IMAGENS
# ===================================================================
if 'mostrar_lista_pecas' not in st.session_state: st.session_state.mostrar_lista_pecas = False
if 'mostrar_desenho' not in st.session_state: st.session_state.mostrar_desenho = False
if 'mostrar_desenho_visualizacao' not in st.session_state: st.session_state.mostrar_desenho_visualizacao = False
if 'mostrar_lista_visualizacao' not in st.session_state: st.session_state.mostrar_lista_visualizacao = False
if 'mostrar_buscador_modelo' not in st.session_state: st.session_state.mostrar_buscador_modelo = False

if 'mostrar_grafico' not in st.session_state:
    st.session_state.mostrar_grafico = False
# Esta fun√ß√£o garante que as imagens sejam carregadas de forma segura.
@st.cache_data
def image_to_base64(img_path):
    """Converte um arquivo de imagem para string base64."""
    try:
        path = Path(img_path)
        with path.open("rb") as f:
            return base64.b64encode(f.read()).decode()
    except FileNotFoundError:
        # Retorna um pixel transparente se a imagem n√£o for encontrada
        return "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="
# ===================================================================
# NOVA FUN√á√ÉO PARA EXIBIR PDF
# ===================================================================
def mostrar_pdf(caminho_arquivo, legenda="Visualiza√ß√£o do Documento"):
    """Exibe a primeira p√°gina de um PDF como imagem diretamente no Streamlit."""
    try:
        import fitz  # PyMuPDF
        from PIL import Image
        import io
        
        # Abre o arquivo PDF
        doc = fitz.open(caminho_arquivo)
        
        # Seleciona a primeira p√°gina
        page = doc.load_page(0)
        
        # Renderiza a p√°gina como imagem (aumentando a resolu√ß√£o)
        zoom = 3.0  # Aumenta a qualidade
        mat = fitz.Matrix(zoom, zoom)
        pix = page.get_pixmap(matrix=mat)
        
        # Converte para formato PIL Image
        img_bytes = pix.tobytes("png")
        image = Image.open(io.BytesIO(img_bytes))
        
        # CORRE√á√ÉO: Usa a legenda que foi passada como par√¢metro
        st.image(image, caption=legenda, use_container_width=True)
        
    except FileNotFoundError:
        st.warning(f"Arquivo n√£o encontrado para este modelo.")
    except Exception as e:
        st.error(f"N√£o foi poss√≠vel exibir o PDF: {e}")

# ===================================================================
# 1. DICION√ÅRIO DE TRADU√á√ïES (ID√äNTICO AO SEU ORIGINAL)
# ===================================================================
ATIVAR_ORCAMENTO = False # Mude para False se quiser desativar

TRADUCOES = {
    'pt': {
        'page_title': "Seletor Higra Mining",
        'main_title': "Seletor de Bombas Hidr√°ulicas Higra Mining",
        'welcome_message': "Bem-vindo! Entre com os dados do seu ponto de trabalho para encontrar a melhor solu√ß√£o.",
        'input_header': "Par√¢metros de Entrada",
        'eletric_freq_title': "Frequ√™ncia El√©trica",
        'freq_header': "Frequ√™ncia",
        'flow_header': "**Vaz√£o Desejada**",
        'graph_header': "üìä Gr√°fico de Performance",
        'drawing_header': "üìê Desenho Dimensional",
        'selector_tab_label': "Seletor por Ponto de Trabalho",
        'finder_tab_label': "Buscador por Modelo",
        'parts_list_header': "üìã Lista de Pe√ßas",
        'view_graph_button': "Visualizar Gr√°fico",
        'close_graph_button': "Fechar Gr√°fico",
        'pressure_header': "**Press√£o Desejada**",
        'flow_value_label': "Valor da Vaz√£o",
        'pressure_value_label': "Valor da Press√£o",
        'view_drawing_button': "Visualizar Desenho",
        'show_finder_button': "üîé Buscar por Modelo da Bomba",
        'view_parts_list_button': "Visualizar Lista de Pe√ßas",
        'close_view_button': "Fechar Visualiza√ß√£o",
        'flow_unit_label': "Unidade Vaz√£o",
        'finder_header': "Busque diretamente pelo modelo da bomba",
        'model_select_label': "1. Selecione o Modelo",
        'motor_select_label': "2. Selecione o Motor (CV)",
        'find_pump_button': "Buscar Bomba",
        'pressure_unit_label': "Unidade Press√£o",
        'converted_values_info': "Valores convertidos para a busca: **Vaz√£o: {vazao} m¬≥/h** | **Press√£o: {pressao} mca**",
        'search_button': "Buscar Melhor Op√ß√£o",
        'dimensional_drawing_button': "Desenho Dimensional",
        'dimensional_drawing_warning': "Aten√ß√£o: O Desenho Dimensional √© um documento de refer√™ncia e pode conter varia√ß√µes. Em caso de d√∫vida ou para confirma√ß√£o mais detalhada, por favor, entre em contato.",
        'parts_list_button': "Lista de Pe√ßas",
        'parts_list_warning': "Aten√ß√£o: A lista de pe√ßas √© um documento de refer√™ncia e pode conter varia√ß√µes. Em caso de d√∫vida ou para confirma√ß√£o mais detalhada, por favor, entre em contato.",
        'download_parts_list_button': "Baixar Lista de Pe√ßas",
        'parts_list_unavailable': "Lista de pe√ßas indispon√≠vel. Por favor, entre em contato para receber.",
        'spinner_text': "Calculando as melhores op√ß√µes para {freq}...",
        'results_header': "Resultados da Busca",
        'solution_unique': "‚úÖ Solu√ß√£o encontrada com **BOMBA √öNICA**:",
        'solution_parallel': "‚ö†Ô∏è Nenhuma bomba √∫nica com bom rendimento. Alternativa: **DUAS BOMBAS EM PARALELO**:",
        'solution_parallel_info': "A vaz√£o e pot√™ncia abaixo s√£o POR BOMBA. Vaz√£o total = 2x.",
        'solution_series': "‚ö†Ô∏è Nenhuma op√ß√£o √∫nica ou paralela. Alternativa: **DUAS BOMBAS EM S√âRIE**:",
        'solution_series_info': "A press√£o abaixo √© POR BOMBA. Press√£o total = 2x.",
        'no_solution_error': "‚ùå Nenhuma bomba encontrada. Tente outros valores.",
        'quote_button_start': "Fazer Or√ßamento",
        'quote_options_header': "Passo 1: Selecione os Opcionais da Bomba",
        'quote_continue_button': "Continuar para o Pr√≥ximo Passo",
        'quote_contact_header': "Passo 2: Seus Dados de Contato",
        'quote_form_name': "Seu Nome *",
        'quote_form_email': "Seu E-mail *",
        'quote_form_message': "Mensagem (opcional)",
        'quote_form_button': "Enviar Pedido de Or√ßamento",
        'quote_form_warning': "Por favor, preencha seu nome e e-mail.",
        'quote_form_success': "Pedido pronto para ser enviado!",
        'download_drawing_button': "Baixar Desenho Dimensional",
        'performance_note': "Nota: Nossos c√°lculos avan√ßados para encontrar a bomba ideal podem levar alguns segundos. Agradecemos a sua paci√™ncia!",
        'drawing_unavailable': "Desenho dimensional indispon√≠vel. Entre em contato para receber.",
        'contact_button': "Contato",
        'quote_form_click_here': "Clique aqui para abrir e enviar o e-mail",
        'quote_form_info': "Seu programa de e-mail padr√£o ser√° aberto com todas as informa√ß√µes preenchidas.",
        'email_subject': "Pedido de Or√ßamento via Seletor de Bombas - {nome}",
        'email_body': """Ol√°,\n\nUm novo pedido de or√ßamento foi gerado atrav√©s do Seletor de Bombas.\n\nDADOS DO CLIENTE:\n- Nome: {nome}\n- E-mail: {email}\n\nMENSAGEM:\n{mensagem}\n\n---------------------------------\nPAR√ÇMETROS DA BUSCA:\n- Frequ√™ncia: {freq}\n- Vaz√£o: {vazao} m¬≥/h\n- Press√£o: {pressao} mca\n\n---------------------------------\nRESULTADOS ENCONTRADOS:\n{tabela_resultados}"""
    },
    'en': {
        'page_title': "Higra Mining Selector",
        'main_title': "Higra Mining Hydraulic Pump Selector",
        'welcome_message': "Welcome! Enter your duty point data to find the best solution.",
        'input_header': "Input Parameters",
        'eletric_freq_title': "Electrical Frequency",
        'freq_header': "Frequency",
        'flow_header': "**Desired Flow**",
        'pressure_header': "**Desired Head**",
        'flow_value_label': "Flow Value",
        'finder_header': "Search directly by pump model",
        'model_select_label': "1. Select Model",
        'motor_select_label': "2. Select Motor (CV)",
        'find_pump_button': "Find Pump",
        'pressure_value_label': "Head Value",
        'selector_tab_label': "Selector by Duty Point",
        'finder_tab_label': "Search by Model",
        'flow_unit_label': "Flow Unit",
        'graph_header': "üìä Performance Chart",
        'drawing_header': "üìê Dimensional Drawing",
        'parts_list_header': "üìã Parts List",
        'view_graph_button': "View Chart",
        'show_finder_button': "üîé Search by Pump Model",
        'close_graph_button': "Close Chart",
        'pressure_unit_label': "Head Unit",
        'view_drawing_button': "View Drawing",
        'view_parts_list_button': "View Parts List",
        'close_view_button': "Close View",
        'parts_list_button': "Parts List",
        'parts_list_warning': "Attention: The parts list is a reference document and may contain variations. If in doubt or for more detailed confirmation, please contact us.",
        'download_parts_list_button': "Download Parts List",
        'parts_list_unavailable': "Parts list unavailable. Please contact us to receive it.",
        'converted_values_info': "Converted values for search: **Flow: {vazao} m¬≥/h** | **Head: {pressao} mca**",
        'search_button': "Find Best Option",
        'spinner_text': "Calculating the best options for {freq}...",
        'results_header': "Search Results",
        'dimensional_drawing_button': "Dimensional Drawing",
        'dimensional_drawing_warning': "Attention: The Dimensional Drawing is a reference document and may contain variations. If in doubt or for more detailed confirmation, please contact us.",
        'solution_unique': "‚úÖ Solution found with a **SINGLE PUMP**:",
        'solution_parallel': "‚ö†Ô∏è No single pump with good efficiency. Alternative: **TWO PUMPS IN PARALLEL**:",
        'solution_parallel_info': "Flow and power below are PER PUMP. Total flow = 2x.",
        'solution_series': "‚ö†Ô∏è No single or parallel option. Alternative: **TWO PUMPS IN SERIES**:",
        'solution_series_info': "Head below is PER PUMP. Total head = 2x.",
        'no_solution_error': "‚ùå No pump found. Try other values.",
        'quote_button_start': "Request a Quote",
        'quote_options_header': "Step 1: Select Pump Options",
        'quote_continue_button': "Continue to Next Step",
        'quote_contact_header': "Step 2: Your Contact Information",
        'quote_form_name': "Your Name *",
        'download_drawing_button': "Download Dimensional Drawing",
        'drawing_unavailable': "Dimensional drawing unavailable. Please contact us to receive it.",
        'contact_button': "Contact",
        'performance_note': "Note: Our advanced calculations to find the ideal pump may take a few seconds. We appreciate your patience!",
        'quote_form_email': "Your Email *",
        'quote_form_message': "Message (optional)",
        'quote_form_button': "Send Quote Request",
        'quote_form_warning': "Please fill in your name and email.",
        'quote_form_success': "Request ready to be sent!",
        'quote_form_click_here': "Click here to open and send the email",
        'quote_form_info': "Your default email client will open with all the information pre-filled.",
        'email_subject': "Quote Request via Pump Selector - {nome}",
        'email_body': """Hello,\n\nA new quote request has been generated through the Pump Selector.\n\nCUSTOMER DATA:\n- Name: {nome}\n- Email: {email}\n\nMESSAGE:\n{mensagem}\n\n---------------------------------\nSEARCH PARAMETERS:\n- Frequency: {freq}\n- Flow: {vazao} m¬≥/h\n- Head: {pressao} mca\n\n---------------------------------\nRESULTS FOUND:\n{tabela_resultados}"""
    },
    'es': {
        'page_title': "Selector Higra Mining",
        'main_title': "Selector de Bombas Hidr√°ulicas Higra Mining",
        'welcome_message': "¬°Bienvenido! Ingrese los datos de su punto de trabajo para encontrar la mejor soluci√≥n.",
        'input_header': "Par√°metros de Entrada",
        'eletric_freq_title': "Frecuencia El√©ctrica",
        'freq_header': "Frecuencia",
        'flow_header': "**Caudal Deseado**",
        'pressure_header': "**Altura Deseada**",
        'show_finder_button': "üîé Buscar por Modelo de Bomba",
        'flow_value_label': "Valor del Caudal",
        'graph_header': "üìä Gr√°fico de Rendimiento",
        'drawing_header': "üìê Dibujo Dimensional",
        'selector_tab_label': "Selector por Punto de Trabajo",
        'finder_tab_label': "Buscador por Modelo",
        'parts_list_header': "üìã Lista de Repuestos",
        'view_graph_button': "Visualizar Gr√°fico",
        'close_graph_button': "Cerrar Gr√°fico",
        'view_drawing_button': "Visualizar Dibujo",
        'view_parts_list_button': "Visualizar Lista de Repuestos",
        'close_view_button': "Cerrar Visualizaci√≥n",
        'pressure_value_label': "Valor de la Altura",
        'finder_header': "Busque directamente por el modelo de la bomba",
        'model_select_label': "1. Seleccione el Modelo",
        'motor_select_label': "2. Seleccione el Motor (CV)",
        'find_pump_button': "Buscar Bomba",
        'flow_unit_label': "Unidad Caudal",
        'parts_list_button': "Lista de Repuestos",
        'parts_list_warning': "Atenci√≥n: La lista de repuestos es un documento de referencia y puede contener variaciones. En caso de duda o para una confirmaci√≥n m√°s detallada, p√≥ngase en contacto.",
        'download_parts_list_button': "Descargar Lista de Repuestos",
        'parts_list_unavailable': "Lista de repuestos no disponible. Por favor, p√≥ngase en contacto para recibirla.",
        'pressure_unit_label': "Unidad Altura",
        'converted_values_info': "Valores convertidos para la b√∫squeda: **Caudal: {vazao} m¬≥/h** | **Altura: {pressao} mca**",
        'search_button': "Buscar Mejor Opci√≥n",
        'dimensional_drawing_button': "Dibujo Dimensional",
        'dimensional_drawing_warning': "Atenci√≥n: El Dibujo Dimensional es un documento de referencia y puede contener variaciones. En caso de duda o para una confirmaci√≥n m√°s detallada, por favor, p√≥ngase en contacto.",
        'spinner_text': "Calculando las mejores opciones para {freq}...",
        'results_header': "Resultados de la B√∫squeda",
        'solution_unique': "‚úÖ Soluci√≥n encontrada con **BOMBA √öNICA**:",
        'solution_parallel': "‚ö†Ô∏è Ninguna bomba √∫nica con buen rendimiento. Alternativa: **DOS BOMBAS EN PARALELO**:",
        'solution_parallel_info': "El caudal y la potencia a continuaci√≥n son POR BOMBA. Caudal total = 2x.",
        'solution_series': "‚ö†Ô∏è Ninguna opci√≥n √∫nica o en paralelo. Alternativa: **DOS BOMBAS EN SERIE**:",
        'solution_series_info': "La altura a continuaci√≥n es POR BOMBA. Altura total = 2x.",
        'no_solution_error': "‚ùå No se encontr√≥ ninguna bomba. Pruebe con otros valores.",
        'quote_button_start': "Solicitar Cotizaci√≥n",
        'quote_options_header': "Paso 1: Seleccione Opcionales de la Bomba",
        'quote_continue_button': "Continuar al Siguiente Paso",
        'quote_contact_header': "Paso 2: Sus Datos de Contacto",
        'quote_form_name': "Su Nombre *",
        'quote_form_email': "Su Correo Electr√≥nico *",
        'quote_form_message': "Mensaje (opcional)",
        'download_drawing_button': "Descargar Dibujo Dimensional",
        'drawing_unavailable': "Dibujo dimensional no disponible. Cont√°ctenos para recibirlo.",
        'contact_button': "Contacto",
        'performance_note': "Nota: Nuestros c√°lculos avanzados para encontrar la bomba ideal pueden tardar unos segundos. ¬°Agradecemos su paciencia!",
        'quote_form_button': "Enviar Solicitud de Cotizaci√≥n",
        'quote_form_warning': "Por favor, complete su nombre y correo electr√≥nico.",
        'quote_form_success': "¬°Solicitud lista para ser enviada!",
        'quote_form_click_here': "Haga clic aqu√≠ para abrir y enviar el correo",
        'quote_form_info': "Su cliente de correo electr√≥nico predeterminado se abrir√° con toda la informaci√≥n completada.",
        'email_subject': "Solicitud de Cotizaci√≥n v√≠a Selector de Bombas - {nome}",
        'email_body': """Hola,\n\nSe ha generado una nueva solicitud de cotizaci√≥n a trav√©s del Selector de Bombas.\n\nDATOS DEL CLIENTE:\n- Nombre: {nome}\n- Correo Electr√≥nico: {email}\n\nMENSAJE:\n{mensagem}\n\n---------------------------------\nPAR√ÅMETROS DE B√öSQUEDA:\n- Frecuencia: {freq}\n- Caudal: {vazao} m¬≥/h\n- Altura: {pressao} mca\n\n---------------------------------\nRESULTADOS ENCONTRADOS:\n{tabela_resultados}"""
    }
}

# ===================================================================
# FUN√á√ïES GLOBAIS E CONSTANTES (DO SEU C√ìDIGO ORIGINAL)
# ===================================================================
MOTORES_PADRAO = np.array([
    15, 20, 25, 30, 40, 50, 60, 75, 100, 125, 150, 175, 200, 250, 300,
    350, 400, 450, 500, 550, 600
])

def encontrar_motor_final(potencia_real):
    if pd.isna(potencia_real): return np.nan
    candidatos = MOTORES_PADRAO[MOTORES_PADRAO >= potencia_real]
    return candidatos.min() if len(candidatos) > 0 else np.nan

@st.cache_data
def carregar_e_processar_dados(caminho_arquivo):

    try:
        df = pd.read_excel(caminho_arquivo)
        df.columns = df.columns.str.strip().str.upper()
    except FileNotFoundError:
        # st.error(f"Erro: Arquivo '{caminho_arquivo}' n√£o encontrado.")
        print(f"Erro: Arquivo '{caminho_arquivo}' n√£o encontrado.")
        return None
    except Exception as e:
        # st.error(f"Ocorreu um erro ao ler o Excel: {e}")
        print(f"Ocorreu um erro ao ler o Excel: {e}")
        return None
        
    df["MOTOR PADR√ÉO (CV)"] = df["POT√äNCIA (HP)"].apply(encontrar_motor_final)
    def extrair_rotor_num(rotor_str):
        match = re.match(r"(\d+)(?:\s*\((\d+)¬∞\))?", str(rotor_str))
        if match:
            base = int(match.group(1)); grau = int(match.group(2)) if match.group(2) else 0
            return base + grau / 100
        return np.nan
    df["ROTORNUM"] = df["ROTOR"].apply(extrair_rotor_num)
    df["ROTOR_MIN_MODELO"] = df.groupby("MODELO")["ROTORNUM"].transform("min")
    df["ROTOR_MAX_MODELO"] = df.groupby("MODELO")["ROTORNUM"].transform("max")
    df["PRESSAO_MAX_MODELO"] = df.groupby("MODELO")["PRESS√ÉO (MCA)"].transform("max")
    df['POTENCIA_MAX_FAMILIA'] = df.groupby('MODELO')['POT√äNCIA (HP)'].transform('max')
    intervalos_vazao = df.groupby(["MODELO", "ROTOR"])["VAZ√ÉO (M¬≥/H)"].agg(["min", "max"]).reset_index()
    df = pd.merge(df, intervalos_vazao, on=["MODELO", "ROTOR"], how="left", suffixes=("", "_range"))
    df["VAZAO_CENTRO"] = (df["min"] + df["max"]) / 2
    # Adicionado + 1e-9 para evitar divis√£o por zero se min == max
    df["ERRO_RELATIVO"] = ((df["VAZ√ÉO (M¬≥/H)"] - df["VAZAO_CENTRO"]) / (df["max"] - df["min"] + 1e-9)) * 100
    df["ABS_ERRO_RELATIVO"] = df["ERRO_RELATIVO"].abs()
    return df
# ===================================================================
# NOVA FUN√á√ÉO OTIMIZADA PARA O BUSCADOR POR MODELO
# ===================================================================
def buscar_por_modelo_e_motor(df, modelo, motor):
    """
    Fun√ß√£o r√°pida e simples para buscar a melhor bomba quando o modelo e o motor j√° s√£o conhecidos.
    """
    if df is None or df.empty:
        return pd.DataFrame()

    # Filtro direto e r√°pido no DataFrame
    df_filtrado = df[
        (df['MODELO'] == modelo) &
        (df['MOTOR PADR√ÉO (CV)'] == motor)
    ]
    
    if df_filtrado.empty:
        return pd.DataFrame()
        
    # Pega a melhor op√ß√£o baseada no maior rendimento
    melhor_opcao = df_filtrado.loc[df_filtrado['RENDIMENTO (%)'].idxmax()]
    
    # Formata o resultado para ser compat√≠vel com o resto da interface
    resultado_df = pd.DataFrame([melhor_opcao])
    
    # Prepara as colunas finais
    colunas_finais = [
       'MODELO', 'ROTOR', 'VAZ√ÉO (M¬≥/H)', 'PRESS√ÉO (MCA)', 'ERRO_PRESSAO', 'ERRO_RELATIVO',
       'RENDIMENTO (%)', 'POT√äNCIA (HP)', 'MOTOR FINAL (CV)'
    ]
    
    # Renomeia 'MOTOR PADR√ÉO (CV)' para 'MOTOR FINAL (CV)' para consist√™ncia
    resultado_df = resultado_df.rename(columns={'MOTOR PADR√ÉO (CV)': 'MOTOR FINAL (CV)'})

    # Remove a coluna de texto 'ROTOR' e renomeia 'ROTORNUM'
    if 'ROTOR' in resultado_df.columns:
        resultado_df = resultado_df.drop(columns=['ROTOR'])
    resultado_df = resultado_df.rename(columns={'ROTORNUM': 'ROTOR'})
    
    # Garante que apenas colunas existentes sejam retornadas
    colunas_presentes = [col for col in colunas_finais if col in resultado_df.columns]
    
    return resultado_df[colunas_presentes]
# ===================================================================
# FUN√á√ÉO PRINCIPAL COM A L√ìGICA DE FILTRAGEM CORRIGIDA
# ===================================================================
def filtrar_e_classificar(df, vazao, pressao, top_n=5, limite_desempate_rendimento=3):
    if df is None or df.empty: 
        return pd.DataFrame()

    # 1. Filtro inicial por vaz√£o (mais eficiente)
    mask_vazao = df["VAZ√ÉO (M¬≥/H)"] == vazao
    if not mask_vazao.any():
        return pd.DataFrame()

    df_vazao = df.loc[mask_vazao].copy()
    
    # 2. Calcular press√µes min/max por modelo sem m√∫ltiplos merges
    min_max = df_vazao.groupby('MODELO')['PRESS√ÉO (MCA)'].agg(['min', 'max']).reset_index()
    min_max.columns = ['MODELO', 'PRESSAO_DO_ROTOR_MIN', 'PRESSAO_DO_ROTOR_MAX']
    
    df_vazao = df_vazao.merge(min_max, on='MODELO', how='left')
    
    # 3. Calcular limites e filtrar de forma vetorizada
    limite_inferior = df_vazao['PRESSAO_DO_ROTOR_MIN'] * 0.99
    limite_superior = df_vazao['PRESSAO_DO_ROTOR_MAX'] * 1.01
    
    mask_limites = (pressao >= limite_inferior) & (pressao <= limite_superior)
    df_filtrado = df_vazao.loc[mask_limites].copy()
    
    if df_filtrado.empty:
        return pd.DataFrame()

    # Restante do seu c√≥digo (preservado)
    df_filtrado["ERRO_PRESSAO"] = df_filtrado["PRESS√ÉO (MCA)"] - pressao
    df_filtrado["MOTOR FINAL (CV)"] = df_filtrado["POT√äNCIA (HP)"].apply(encontrar_motor_final)
    df_filtrado["ERRO_PRESSAO_ABS"] = df_filtrado["ERRO_PRESSAO"].abs()
    

    # ===================================================================
    # A PARTIR DAQUI, O SEU C√ìDIGO ORIGINAL √â PRESERVADO
    # ===================================================================

    # ETAPA 2: C√ÅLCULOS B√ÅSICOS
    df_filtrado["ERRO_PRESSAO"] = df_filtrado["PRESS√ÉO (MCA)"] - pressao
    df_filtrado["MOTOR FINAL (CV)"] = df_filtrado["POT√äNCIA (HP)"].apply(encontrar_motor_final)
    df_filtrado["ERRO_PRESSAO_ABS"] = df_filtrado["ERRO_PRESSAO"].abs()
    
    if df_filtrado.empty: return pd.DataFrame()
    
    # ETAPA 3: L√ìGICA DE ORDENA√á√ÉO
    df_grupo_controle = df_filtrado.loc[df_filtrado.groupby('MODELO')['ERRO_PRESSAO_ABS'].idxmin()].copy()

    if df_grupo_controle.empty: return pd.DataFrame()

    min_erro_rel = df_grupo_controle["ABS_ERRO_RELATIVO"].min()
    df_grupo_controle["DIF_ERRO_REL"] = df_grupo_controle["ABS_ERRO_RELATIVO"] - min_erro_rel
    
    grupo_A = df_grupo_controle[df_grupo_controle["DIF_ERRO_REL"] <= 10].copy()
    grupo_B = df_grupo_controle[df_grupo_controle["DIF_ERRO_REL"] > 10].copy()
    
    grupo_A = grupo_A.sort_values(by="RENDIMENTO (%)", ascending=False)
    
    if not grupo_A.empty:
        max_rend = grupo_A["RENDIMENTO (%)"].max()
        grupo_A["DIF_REND"] = max_rend - grupo_A["RENDIMENTO (%)"]
        
        subgrupo_A1 = grupo_A[grupo_A["DIF_REND"] <= limite_desempate_rendimento].copy()
        subgrupo_A2 = grupo_A[grupo_A["DIF_REND"] > limite_desempate_rendimento].copy()
        
        subgrupo_A1 = subgrupo_A1.sort_values(by="ERRO_PRESSAO_ABS", ascending=True)
        
        grupo_A = pd.concat([subgrupo_A1, subgrupo_A2])
    
    grupo_B = grupo_B.sort_values(by="ABS_ERRO_RELATIVO", ascending=True)
    
    df_resultado = pd.concat([grupo_A, grupo_B])
    df_resultado = df_resultado.head(top_n)
    df_resultado = df_resultado.drop(columns=["DIF_ERRO_REL", "DIF_REND"], errors="ignore")
    
    colunas_finais = [
       'MODELO', 'ROTOR', 'VAZ√ÉO (M¬≥/H)', 'PRESS√ÉO (MCA)', 'ERRO_PRESSAO', 'ERRO_RELATIVO',
       'RENDIMENTO (%)', 'POT√äNCIA (HP)', 'MOTOR FINAL (CV)'
    ]
    
    # CORRE√á√ÉO: Para evitar o erro de coluna duplicada, removemos a coluna 'ROTOR' original (texto)
    # antes de renomear a coluna num√©rica 'ROTORNUM' para 'ROTOR'.
    if 'ROTOR' in df_resultado.columns:
        df_resultado = df_resultado.drop(columns=['ROTOR'])
        
    # Renomeando ROTORNUM para ROTOR para corresponder √† sua sa√≠da desejada
    df_resultado = df_resultado.rename(columns={'ROTORNUM': 'ROTOR'})
    
    colunas_presentes = [col for col in colunas_finais if col in df_resultado.columns]
    
    return df_resultado[colunas_presentes]

def selecionar_bombas(df, vazao_desejada, pressao_desejada, top_n=5):
    resultado_unico = filtrar_e_classificar(df, vazao_desejada, pressao_desejada, top_n)
    if not resultado_unico.empty and resultado_unico.iloc[0]["RENDIMENTO (%)"] > 50:
        return resultado_unico, "unica"
    resultado_paralelo = filtrar_e_classificar(df, vazao_desejada / 2, pressao_desejada, top_n)
    if not resultado_paralelo.empty:
        return resultado_paralelo, "paralelo"
    resultado_serie = filtrar_e_classificar(df, vazao_desejada, pressao_desejada / 2, top_n)
    if not resultado_serie.empty:
        return resultado_serie, "serie"
    return pd.DataFrame(), "nenhuma"

# ===================================================================
# INTERFACE STREAMLIT (VERS√ÉO EST√ÅVEL COM NOVO DESIGN)
# ===================================================================

# --- CONFIGURA√á√ïES INICIAIS ---
query_params = st.query_params
if 'lang' in query_params:
    lang_from_url = query_params['lang']
    if lang_from_url in ['pt', 'en', 'es']:
        st.session_state.lang = lang_from_url
if 'lang' not in st.session_state: st.session_state.lang = 'pt'
if 'resultado_busca' not in st.session_state: st.session_state.resultado_busca = None
if 'mailto_link' not in st.session_state: st.session_state.mailto_link = None
if 'iniciar_orcamento' not in st.session_state: st.session_state.iniciar_orcamento = False
if 'opcionais_selecionados' not in st.session_state: st.session_state.opcionais_selecionados = None

st.set_page_config(layout="wide", page_title=TRADUCOES[st.session_state.lang]['page_title'])

# --- ESTILOS CSS APRIMORADOS ---
COR_PRIMARIA = "#134883"
COR_SECUNDARIA = "#F8AC2E"
COR_FUNDO = "#F0F5FF"
COR_TEXTO = "#333333"

st.markdown(f"""
<style>
    /* Configura√ß√µes gerais */
    .stApp {{
        background-color: {COR_FUNDO};
        color: {COR_TEXTO};
    }}
    
    /* Cabe√ßalhos */
    h1, h2, h3, h4, h5, h6 {{
        color: {COR_PRIMARIA};
    }}
    
    /* Bot√µes Principais (CORRIGIDO) */
    .stButton>button {{
        border: 2px solid {COR_PRIMARIA} !important;
        background-color: {COR_PRIMARIA} !important;
        color: white !important;
        font-weight: bold !important;
        transition: all 0.3s ease !important;
        border-radius: 8px !important;
    }}
    .stButton>button:hover {{
        background-color: white !important;
        color: {COR_PRIMARIA} !important;
    }}
    
    /* Alertas */
    .stAlert > div {{ border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); padding: 15px 20px; }}
    .stAlert-success {{ background-color: #e0f2f1; color: {COR_PRIMARIA}; border-left: 5px solid #2ECC71; }}
    .stAlert-warning {{ background-color: #fff8e1; color: #c08b2c; border-left: 5px solid {COR_SECUNDARIA}; }}
    .stAlert-info {{ background-color: #e3f2fd; color: {COR_PRIMARIA}; border-left: 5px solid {COR_PRIMARIA}; }}
    .stAlert-error {{ background-color: #ffebee; color: #b71c1c; border-left: 5px solid #E74C3C; }}

    /* Container de bandeiras */
    .bandeira-container {{ cursor: pointer; transition: all 0.2s ease-in-out; border-radius: 8px; padding: 5px; margin-top: 10px; border: 2px solid transparent; }}
    .bandeira-container:hover {{ transform: scale(1.1); background-color: rgba(19, 72, 131, 0.1); }}
    .bandeira-container.selecionada {{ border: 2px solid {COR_SECUNDARIA}; box-shadow: 0 0 10px rgba(248, 172, 46, 0.5); }}
    .bandeira-img {{ width: 45px; height: 30px; object-fit: cover; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }}

    /* Dataframe estilizado */
    .stDataFrame {{ border: 1px solid #d0d7de; border-radius: 8px; }}

    /* Bot√µes de R√°dio da Frequ√™ncia (NOVO) */
    div[data-baseweb="radio"] label > div:first-child {{
        background-color: {COR_SECUNDARIA} !important; /* Cor Amarela */
        border: 2px solid {COR_SECUNDARIA} !important;
</style>
""", unsafe_allow_html=True)


# ===================================================================
# CABE√áALHO COM LOGO E SELE√á√ÉO DE IDIOMA (VERS√ÉO ATUALIZADA)
# ===================================================================

# Mapeamento das bandeiras para idiomas
bandeiras = {
    "pt": {"nome": "PT", "img": "brasil.png"},
    "en": {"nome": "EN", "img": "uk.png"},
    "es": {"nome": "ES", "img": "espanha.png"}
}

col_logo, col_vazia, col_bandeiras = st.columns([4, 4, 2])

with col_logo:
    try:
        st.image("logo.png", width=900)
    except Exception:
        st.warning("Logo n√£o encontrada.")

with col_bandeiras:
    # Cria colunas para cada bandeira ficarem lado a lado
    flag_cols = st.columns(len(bandeiras))
    for i, (lang_code, info) in enumerate(bandeiras.items()):
        with flag_cols[i]:
            classe_css = "selecionada" if st.session_state.lang == lang_code else ""
            img_base64 = image_to_base64(info["img"])

            # Unimos o texto e a imagem dentro de um √∫nico link (tag <a>).
            # O href="?lang=..." instrui o Streamlit a recarregar a p√°gina com o novo idioma.
            # O target="_self" garante que a p√°gina recarregue na mesma aba.
            st.markdown(f"""
            <a href="?lang={lang_code}" target="_self" style="text-decoration: none;">
                <div style="display: flex; flex-direction: column; align-items: center; font-family: 'Source Sans Pro', sans-serif; font-weight: bold; color: {COR_PRIMARIA};">
                    <span>{info['nome']}</span>
                    <div class="bandeira-container {classe_css}">
                        <img src="data:image/png;base64,{img_base64}" class="bandeira-img">
                    </div>
                </div>
            </a>
            """, unsafe_allow_html=True)




# Atualiza a vari√°vel de tradu√ß√£o AP√ìS a poss√≠vel troca de idioma
T = TRADUCOES[st.session_state.lang]

# T√≠tulo e Mensagem de Boas-vindas
st.title(T['main_title'])
st.write(T['welcome_message'])
st.info(T['performance_note'])
st.divider()


# ===================================================================
# RESTANTE DO SCRIPT ORIGINAL (ID√äNTICO)
# ===================================================================

EMAIL_DESTINO = "seu.email@higra.com.br"
ARQUIVOS_DADOS = { "60Hz": "60Hz.xlsx", "50Hz": "50Hz.xlsx" }
FATORES_VAZAO = { "m¬≥/h": 1.0, "gpm (US)": 0.2271247, "l/s": 3.6 }
FATORES_PRESSAO = { "mca": 1.0, "ftH‚ÇÇO": 0.3048, "bar": 10.197, "kgf/cm¬≤": 10.0 }

# ===================================================================
# SE√á√ÉO DE ENTRADAS (VERS√ÉO CORRIGIDA E REESTRUTURADA)
# ===================================================================

# --- Parte 1: Seletor por Ponto de Trabalho (VERS√ÉO CORRIGIDA) ---
# ===================================================================
# SE√á√ÉO DE ENTRADAS REESTRUTURADA COM ABAS (VERS√ÉO CORRIGIDA)
# ===================================================================

# Cria as duas abas para separar as formas de busca
tab_seletor, tab_buscador = st.tabs([T['selector_tab_label'], T['finder_tab_label']])

# --- Aba 1: Seletor por Ponto de Trabalho ---
with tab_seletor:
    st.markdown(f"#### {T['eletric_freq_title']}")

    col_freq, col_vazio = st.columns([1, 3])
    with col_freq:
        frequencia_selecionada = st.radio(
            T['freq_header'], 
            list(ARQUIVOS_DADOS.keys()), 
            horizontal=True, 
            label_visibility="collapsed",
            key='freq_seletor'
        )

    # Carrega os dados para o SELETOR
    caminho_arquivo_selecionado = ARQUIVOS_DADOS[frequencia_selecionada]
    df_processado = carregar_e_processar_dados(caminho_arquivo_selecionado)

    col_vazao, col_pressao = st.columns(2)
    with col_vazao:
        st.markdown(T['flow_header'])
        sub_col_v1, sub_col_v2 = st.columns([2,1])
        with sub_col_v1: vazao_bruta = st.number_input(T['flow_value_label'], min_value=0.1, value=100.0, step=10.0, label_visibility="collapsed", key='vazao_bruta')
        with sub_col_v2: unidade_vazao = st.selectbox(T['flow_unit_label'], list(FATORES_VAZAO.keys()), label_visibility="collapsed", key='unidade_vazao')
    with col_pressao:
        st.markdown(T['pressure_header'])
        sub_col_p1, sub_col_p2 = st.columns([2,1])
        with sub_col_p1: pressao_bruta = st.number_input(T['pressure_value_label'], min_value=0.1, value=100.0, step=5.0, label_visibility="collapsed", key='pressao_bruta')
        with sub_col_p2: unidade_pressao = st.selectbox(T['pressure_unit_label'], list(FATORES_PRESSAO.keys()), label_visibility="collapsed", key='unidade_pressao')

    vazao_para_busca = round(vazao_bruta * FATORES_VAZAO[unidade_vazao])
    pressao_para_busca = round(pressao_bruta * FATORES_PRESSAO[unidade_pressao])
    st.info(T['converted_values_info'].format(vazao=vazao_para_busca, pressao=pressao_para_busca))

    # Bot√£o do SELETOR, agora dentro de sua pr√≥pria aba
    if df_processado is not None:
        if st.button(T['search_button'], use_container_width=True, key='btn_seletor'):
            # Reseta todos os estados ao iniciar uma nova busca
            st.session_state.resultado_busca = None
            st.session_state.mostrar_grafico = False
            st.session_state.mostrar_desenho = False
            st.session_state.mostrar_lista_pecas = False
            st.session_state.mostrar_desenho_visualizacao = False
            st.session_state.mostrar_lista_visualizacao = False
            
            with st.spinner(T['spinner_text'].format(freq=frequencia_selecionada)):
                resultado, tipo = selecionar_bombas(df_processado, vazao_para_busca, pressao_para_busca, top_n=3)
                if not resultado.empty:
                    st.session_state.resultado_busca = {"resultado": resultado, "tipo": tipo}
                else:
                    st.error(T['no_solution_error'])
            
            st.rerun()

# --- Aba 2: Buscador por Modelo ---
with tab_buscador:
    col_freq_busca, col_modelo_busca, col_motor_busca = st.columns(3)
    
    with col_freq_busca:
        frequencia_buscador = st.radio(
            T['freq_header'], 
            list(ARQUIVOS_DADOS.keys()), 
            horizontal=True, 
            key='freq_buscador'
        )

    # Gra√ßas ao cache, esta linha agora √© instant√¢nea ap√≥s a primeira execu√ß√£o
    caminho_buscador = ARQUIVOS_DADOS[frequencia_buscador]
    df_buscador = carregar_e_processar_dados(caminho_buscador)

    if df_buscador is not None:
        with col_modelo_busca:
            lista_modelos = ["-"] + sorted(df_buscador['MODELO'].unique())
            modelo_selecionado_buscador = st.selectbox(
                T['model_select_label'],
                lista_modelos,
                key='modelo_buscador'
            )

        with col_motor_busca:
            motor_selecionado_buscador = None # Inicializa a vari√°vel para evitar erros
            if modelo_selecionado_buscador and modelo_selecionado_buscador != "-":
                motores_unicos = df_buscador[df_buscador['MODELO'] == modelo_selecionado_buscador]['MOTOR PADR√ÉO (CV)'].unique()
                motores_disponiveis = sorted([motor for motor in motores_unicos if pd.notna(motor)])
                
                if motores_disponiveis:
                    motor_selecionado_buscador = st.selectbox(
                        T['motor_select_label'],
                        motores_disponiveis,
                        key='motor_buscador'
                    )
                else:
                    st.selectbox(T['motor_select_label'], ["-"], disabled=True)
            else:
                st.selectbox(T['motor_select_label'], ["-"], disabled=True)

        # A l√≥gica do bot√£o agora chama a nova fun√ß√£o r√°pida 'buscar_por_modelo_e_motor'
        if modelo_selecionado_buscador and modelo_selecionado_buscador != "-" and motor_selecionado_buscador:
            if st.button(T['find_pump_button'], use_container_width=True, key='btn_find_pump'):
                # Reseta o estado da interface
                st.session_state.resultado_busca = None
                st.session_state.mostrar_grafico = False
                st.session_state.mostrar_desenho = False
                st.session_state.mostrar_lista_pecas = False
                st.session_state.mostrar_desenho_visualizacao = False
                st.session_state.mostrar_lista_visualizacao = False

                # Chama a nova fun√ß√£o r√°pida, que n√£o causa lentid√£o
                resultado = buscar_por_modelo_e_motor(df_buscador, modelo_selecionado_buscador, motor_selecionado_buscador)
                
                if not resultado.empty:
                    st.session_state.resultado_busca = {"resultado": resultado, "tipo": "unica"}
                else:
                    st.session_state.resultado_busca = None # Limpa o resultado se nada for encontrado
                    st.error(T['no_solution_error'])
                
                st.rerun()
                
# O bloco de exibi√ß√£o de resultados abaixo desta linha permanece o mesmo.
# --- Parte 3: Exibi√ß√£o dos Resultados (o c√≥digo abaixo permanece o mesmo) ---
# A linha 'if st.session_state.resultado_busca:' j√° existe no seu c√≥digo,
# ent√£o a substitui√ß√£o termina antes dela.

if st.session_state.resultado_busca:
    st.divider()
    st.header(T['results_header'])
    resultado_data = st.session_state.resultado_busca
    resultado = resultado_data["resultado"]
    tipo = resultado_data["tipo"]
    if tipo == "unica": st.success(T['solution_unique'])
    elif tipo == "paralelo": st.warning(T['solution_parallel']); st.info(T['solution_parallel_info'])
    elif tipo == "serie": st.warning(T['solution_series']); st.info(T['solution_series_info'])
        
    resultado_formatado = resultado.copy()
    for col in ['ERRO_PRESSAO', 'ERRO_RELATIVO', 'RENDIMENTO (%)', 'POT√äNCIA (HP)', 'POT√äNCIA CORRIGIDA (HP)']:
        if col in resultado_formatado.columns:
                resultado_formatado[col] = resultado_formatado[col].map('{:,.2f}'.format)
    st.dataframe(resultado_formatado, hide_index=True, use_container_width=True)
    st.divider()
        
        # ===================================================================
        # SE√á√ÉO DE EXIBI√á√ÉO DO GR√ÅFICO (DENTRO DO BLOCO COM RESULTADOS)
        # ===================================================================
    st.divider()
        # Corrigido para usar a tradu√ß√£o
    st.header(T['graph_header']) 
        
        # Obt√©m o modelo selecionado
    modelo_selecionado = resultado.iloc[0]['MODELO']
    frequencia_str = frequencia_selecionada
    caminho_pdf = f"pdfs/{frequencia_str}/{modelo_selecionado}.pdf"
        
        # Bot√£o estilizado para visualizar o gr√°fico
    if st.button(
        T['view_graph_button'],
        key="btn_visualizar_grafico",
        use_container_width=True,
        type="primary",
    ):
        st.session_state.mostrar_grafico = True
            
    st.divider()

 # ===================================================================
        # SE√á√ÉO DE DOWNLOAD DO DESENHO DIMENSIONAL (COM CAIXA EXPANS√çVEL)
        # ===================================================================
# ADICIONE AS 2 LINHAS ABAIXO
        
    st.header(T['drawing_header'])
        
        # 1. Bot√£o principal que abre/fecha a se√ß√£o do desenho
    if st.button(T['dimensional_drawing_button'], use_container_width=True):
        st.session_state.mostrar_desenho = not st.session_state.get('mostrar_desenho', False)

        # 2. Container que s√≥ aparece quando o bot√£o acima √© clicado
    if st.session_state.get('mostrar_desenho', False):
        with st.container(border=True):
                # Mensagem de aviso padr√£o
            st.info(T['dimensional_drawing_warning'])

                # A l√≥gica de busca do arquivo (que j√° t√≠nhamos) agora fica DENTRO do container
                # -------------------------------------------------------------------------
                
                # a. Obter dados da bomba selecionada (top 1)
            melhor_bomba = resultado.iloc[0]
            modelo_selecionado = melhor_bomba['MODELO']
            motor_alvo = int(melhor_bomba['MOTOR FINAL (CV)'])

                # b. Preparar para a busca na pasta "Desenhos"
            desenho_base_path = Path("Desenhos")
            caminho_desenho_final = None
                
                # c. L√≥gica de busca por motor mais pr√≥ximo
            if desenho_base_path.exists():
                desenhos_candidatos = {} # Dicion√°rio para guardar {motor_disponivel: caminho_completo}
                for path_arquivo in desenho_base_path.glob(f"{modelo_selecionado}*.pdf"):
                    nome_sem_ext = path_arquivo.stem
                    partes = nome_sem_ext.split('_')
                    if len(partes) == 2:
                        try:
                            motor_no_arquivo = int(partes[1])
                            desenhos_candidatos[motor_no_arquivo] = path_arquivo
                        except ValueError:
                            continue
                if desenhos_candidatos:
                    motor_mais_proximo = min(
                        desenhos_candidatos.keys(), 
                        key=lambda motor: abs(motor - motor_alvo)
                    )
                    caminho_desenho_final = desenhos_candidatos[motor_mais_proximo]
                
                # d. Fallback para o nome geral
            if not caminho_desenho_final:
                caminho_geral = desenho_base_path / f"{modelo_selecionado}.pdf"
                if caminho_geral.exists():
                    caminho_desenho_final = caminho_geral

# e. Exibe os bot√µes e a visualiza√ß√£o condicional
            if caminho_desenho_final:
                    # Bot√£o para pr√©-visualizar o PDF como imagem
                if st.button(T['view_drawing_button'], use_container_width=True, type="secondary"):
                    st.session_state.mostrar_desenho_visualizacao = not st.session_state.get('mostrar_desenho_visualizacao', False)

                    # Se o bot√£o de visualizar foi clicado, mostra a imagem e o bot√£o de fechar
                if st.session_state.get('mostrar_desenho_visualizacao', False):
                    mostrar_pdf(caminho_desenho_final, legenda="Desenho Dimensional")
                    if st.button(T['close_view_button'], use_container_width=True, key='fechar_desenho'):
                        st.session_state.mostrar_desenho_visualizacao = False
                        st.rerun()
                    
                    # Bot√£o para fazer o download do arquivo
                with open(caminho_desenho_final, "rb") as pdf_file:
                    st.download_button(
                        label=T['download_drawing_button'],
                        data=pdf_file,
                        file_name=caminho_desenho_final.name,
                        mime="application/pdf",
                        use_container_width=True
                    )
            else:
                st.warning(T['drawing_unavailable'])
                    
                # f. Exibe o bot√£o de Contato em ambos os casos (arquivo encontrado ou n√£o)
            link_contato = "https://wa.me/5551991808303?text=Ol%C3%A1!%20Preciso%20do%20desenho%20dimensional%20de%20uma%20bomba%20Higra%20Mining."
            st.markdown(f'''
            <a href="{link_contato}" target="_blank" style="
                display: block; 
                padding: 0.5rem 1rem; 
                background-color: {COR_PRIMARIA};
                color: white; 
                font-weight: bold; 
                text-align: center;
                text-decoration: none; 
                border-radius: 8px; 
                border: 2px solid {COR_PRIMARIA};
                box-sizing: border-box;
                margin-top: 10px;
            ">
                {T['contact_button']}
            </a>
            ''', unsafe_allow_html=True)
                
    st.divider()

# Adiciona uma linha para separar as se√ß√µes

        # ===================================================================
        # SE√á√ÉO LISTA DE PE√áAS
        # ===================================================================
        
    st.header(T['parts_list_header'])
        
        # 1. Bot√£o principal que abre/fecha a se√ß√£o da lista de pe√ßas
    if st.button(T['parts_list_button'], use_container_width=True):
            # Inverte o estado atual (se era False, vira True, e vice-versa)
        st.session_state.mostrar_lista_pecas = not st.session_state.get('mostrar_lista_pecas', False)

        # 2. Container que s√≥ aparece quando o bot√£o acima for clicado
    if st.session_state.get('mostrar_lista_pecas', False):
        with st.container(border=True):
                # L√≥gica de busca do arquivo (simples, s√≥ por modelo, na pasta "Lista")
            caminho_lista_pecas = Path(f"Lista/{modelo_selecionado}.pdf")
                
                # Link de contato para o WhatsApp
            link_contato_pecas = "https://wa.me/5551991808303?text=Ol%C3%A1!%20Preciso%20de%20ajuda%20com%20uma%20lista%20de%20pe%C3%A7as%20para%20uma%20bomba%20Higra%20Mining."
            botao_contato_html = f'''
            <a href="{link_contato_pecas}" target="_blank" style="
                display: block; 
                padding: 0.5rem 1rem; 
                background-color: {COR_PRIMARIA};
                color: white; 
                font-weight: bold; 
                text-align: center;
                text-decoration: none; 
                border-radius: 8px; 
                border: 2px solid {COR_PRIMARIA};
                box-sizing: border-box;
                margin-top: 10px;
            ">
                {T['contact_button']}
            </a>
            '''

# CASO A: O arquivo da lista de pe√ßas EXISTE
            if caminho_lista_pecas.exists():
                st.info(T['parts_list_warning']) # Mensagem de aviso
                    
                    # Bot√£o para pr√©-visualizar a lista de pe√ßas
                if st.button(T['view_parts_list_button'], use_container_width=True, type="secondary"):
                    st.session_state.mostrar_lista_visualizacao = not st.session_state.get('mostrar_lista_visualizacao', False)

                    # Se o bot√£o de visualizar foi clicado, mostra a imagem e o bot√£o de fechar
                if st.session_state.get('mostrar_lista_visualizacao', False):
                    mostrar_pdf(caminho_lista_pecas, legenda="Lista de Pe√ßas")
                    if st.button(T['close_view_button'], use_container_width=True, key='fechar_lista'):
                        st.session_state.mostrar_lista_visualizacao = False
                        st.rerun()

                    # Bot√£o para fazer o download do arquivo
                with open(caminho_lista_pecas, "rb") as pdf_file:
                    st.download_button(
                        label=T['download_parts_list_button'],
                        data=pdf_file,
                        file_name=caminho_lista_pecas.name,
                        mime="application/pdf",
                        use_container_width=True
                    )
                    
                    # Exibe o bot√£o de contato logo abaixo
                st.markdown(botao_contato_html, unsafe_allow_html=True)

                # CASO B: O arquivo da lista de pe√ßas N√ÉO existe
            else:
                st.warning(T['parts_list_unavailable'])
                    
                    # Exibe apenas o bot√£o de contato
                st.markdown(botao_contato_html, unsafe_allow_html=True)
                    
        # Verifica se devemos mostrar o gr√°fico
    if st.session_state.get('mostrar_grafico', False):
            # O container e tudo dentro dele precisa estar INDENTADO (com mais espa√ßos)
            # para pertencer ao 'if' acima.
        with st.container(border=True):
            st.subheader(f"Modelo: {modelo_selecionado}")
            mostrar_pdf(caminho_pdf, legenda="Gr√°fico de Performance")

                # O bot√£o de fechar tamb√©m deve aparecer junto com o gr√°fico
            if st.button(T['close_graph_button'], key="btn_fechar_grafico", use_container_width=True):
                st.session_state.mostrar_grafico = False
                st.rerun() # Adicionado para fechar o gr√°fico instantaneamente
                
        # O c√≥digo do formul√°rio de or√ßamento que j√° existe continua depois daqui....
                
        # M√≥dulo de Or√ßamento
        if ATIVAR_ORCAMENTO:
            if st.button(T['quote_button_start'], use_container_width=True):
                st.session_state.iniciar_orcamento = not st.session_state.iniciar_orcamento
                st.session_state.mailto_link = None
                st.session_state.opcionais_selecionados = None

            if st.session_state.iniciar_orcamento:
                with st.form("opcionais_form"):
                    st.subheader(T['quote_options_header'])
                    col_op1, col_op2 = st.columns(2)
                    with col_op1:
                        rotor_orc = st.selectbox("Material do Rotor", ["FOFO", "CA40", "INOX34"])
                        difusor_orc = st.selectbox("Material do Difusor", ["FOFO", "CA40", "INOX34"])
                        equalizador_orc = st.selectbox("Equalizador de Press√£o", ["FILTRO EQUALIZADOR", "PIST√ÉO EQUALIZADOR"])
                    with col_op2:
                        sensor_motor_orc = st.selectbox("Sensor Temperatura do Motor", ["1 SENSOR", "3 SENSORES"])
                        sensor_nivel_orc = st.selectbox("Sensor de N√≠vel", ["N√ÉO", "SIM"])
                        crivo_orc = st.selectbox("Crivo", ["SIM", "N√ÉO"])
                    continuar_orcamento = st.form_submit_button(T['quote_continue_button'])
                    if continuar_orcamento:
                        st.session_state.opcionais_selecionados = {
                            "Material do Rotor": rotor_orc,
                            "Material do Difusor": difusor_orc,
                            "Equalizador de Press√£o": equalizador_orc,
                            "Sensor Temperatura do Motor": sensor_motor_orc,
                            "Sensor de N√≠vel": sensor_nivel_orc,
                            "Crivo": crivo_orc
                        }

                if st.session_state.opcionais_selecionados:
                    with st.form("contato_form"):
                        st.subheader(T['quote_contact_header'])
                        nome_cliente = st.text_input(T['quote_form_name'])
                        email_cliente = st.text_input(T['quote_form_email'])
                        mensagem_cliente = st.text_area(T['quote_form_message'])
                        enviar_orcamento = st.form_submit_button(T['quote_form_button'])
                        if enviar_orcamento:
                            if not nome_cliente or not email_cliente:
                                st.warning(T['quote_form_warning'])
                            else:
                                opcionais_texto = "\n\nOPCIONAIS SELECIONADOS PARA O OR√áAMENTO:\n"
                                for chave, valor in st.session_state.opcionais_selecionados.items():
                                    opcionais_texto += f"- {chave}: {valor}\n"
                                tabela_resultados_texto = resultado.to_string()
                                corpo_email = T['email_body'].format(
                                    nome=nome_cliente,
                                    email=email_cliente,
                                    mensagem=mensagem_cliente,
                                    freq=frequencia_selecionada,
                                    vazao=vazao_para_busca,
                                    pressao=pressao_para_busca,
                                    tabela_resultados=tabela_resultados_texto
                                ) + opcionais_texto
                                corpo_email_codificado = quote(corpo_email)
                                assunto = quote(T['email_subject'].format(nome=nome_cliente))
                                st.session_state.mailto_link = f"mailto:{EMAIL_DESTINO}?subject={assunto}&body={corpo_email_codificado}"

                if st.session_state.mailto_link:
                    st.success(T['quote_form_success'])
                    st.markdown(f'''
                        <a href="{st.session_state.mailto_link}" target="_blank" style="
                            display: inline-block; padding: 12px 20px; background-color: {COR_SECUNDARIA};
                            color: {COR_PRIMARIA}; font-weight: bold; text-align: center;
                            text-decoration: none; border-radius: 8px; border: 2px solid {COR_PRIMARIA};
                        ">
                            {T['quote_form_click_here']}
                        </a>
                    ''', unsafe_allow_html=True)
                    st.info(T['quote_form_info'])
                    

